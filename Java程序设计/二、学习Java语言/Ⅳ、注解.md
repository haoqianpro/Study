# 注解
> 注解是元数据的一种形式，提供程序的信息，对代码本身并无直接影响

## 注解的应用

  + 为编译器提供信息，检测错误或抑制警告
  + 编译时和部署时处理，软件工具可以处理注解信息生成代码或其他数据
  + 运行时处理

## 注解基础

+ 注解由@开始，可带参数也可不带参数，如果只有一个参数可以舍弃参数名；注解可叠加
+ 哪里可以用注解
  + 声明，类的声明，字段的声明，方法的声明
  + 类型注解
    + 类实例创建表达式，例`new @Interned MyObject();`
    + 类型转换，例`myString = (@NonNull String) str;`
    + 类声明中接口实现子句，例`class UnmodifiableList<T> implements
        @Readonly List<@Readonly T> { ... }`
    + 异常抛出声明，例`void monitorTemperature() throws
        @Critical TemperatureException { ... }`
+ 声明注解 可以选择是否提供默认值,形式如下
```
@interface ClassPreamble {
   String author();
   int currentRevision() default 1;
   ......
   // Note use of array
   String[] reviewers();
}
```
+ 预定义的注解
  + `@Deprecated`         指出备注此元素已过时，不应该再使用
  + `@Override`           告知编译器此元素覆写了父类中元素
  + `@SuppressWarnings`   抑制要抛出的异常，编译器抛出的异常有两种，`deprecation`和`unchecked`
  + `@SafeVarargs`        和varargs相关的unchecked异常被抑制
  + `@FunctionalInterface`表明这个接口是函数接口

+ 元注解-注解注解的注解
  + `@Retention`   指示被标记的注解保留在什么阶段
    + `RetentionPolicy.SOURCE`  被标记的注解只保留在源码阶段，会被编译器忽略
    + `RetentionPolicy.CLASS`   编译器处理并且会被JVM忽略
    + `RetentionPolicy.RUNTIME` 由JVM处理
  + `@Documented`  指示被标记注解会出现在javadoc生成的文本中
  + `@Target`      指示被标记注解可以处理的元素类型
    + `ElementType.ANNOTATION_TYPE`   可以应用于注解类型
    + `ElementType.CONSTRUCTOR`       可以应用于构造方法
    + `ElementType.FIELD`             可以应用于字段或属性
    + `ElementType.LOCAL_VARIABLE`    可以应用于局部变量
    + `ElementType.METHOD`            可以应用于方法
    + `ElementType.PACKAGE`           可以用于包的声明
    + `ElementType.PARAMETER`         可以应用于方法的参数
    + `ElementType.TYPE`              可以应用于类中任意元素
  + `@Inherited`    被标记注解应用于类时，该类的子类可继承该注解
  + `@Repeatable`   被标记注解可重复应用

+ 可重复注解 为了使一个注解可以重复使用，重复的注解都存储在Java编译器自动生成的一个容器注解中，为了编译器能完成这个任务，需要声明两个注解类型
  + 声明一个可重复注解类型，声明一个需要重复使用的注解类型时，添加`@Repeatable(xxxx)`值是容器注解的类型
  + 声明一个容器注解类型，里面必须包含可重复注解类型的value数组，例
  ```
  import java.lang.annotation.Repeatable;

  @Repeatable(Schedules.class)
  public @interface Schedule {
    String dayOfMonth() default "first";
    String dayOfWeek() default "Mon";
    int hour() default 12;
  }

  public @interface Schedules {
    Schedule[] value();
  }
  ```
