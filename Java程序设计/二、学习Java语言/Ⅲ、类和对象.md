# Java语言中的类和对象

## 类

+ 类的声明有如下内容
  + 修饰符
  + 类名（首字母大写）
  + 继承的父类
  + 实现的接口
  + 类体
+ 成员变量：字段，局部变量，参数
+ 方法：
  + 签名：函数名和参数类型
  + 方法命名：首单词为动词，后续单词首字母大写
  + 方法重载：通过方法签名，有相同的方法名，但参数类型列表不同
+ 构造方法
  + 未给出构造方法时，编译器生成默认的无参构造方法，并会自动调用父类的无参构造方法，若父类无无参构造方法，则报错
+ 调用方法时传参
  + 方法声明中的变量列表称为`Parameters`，实际传入方法的值称为`Arguments`
  + 方法参数可以使用基本数据类型和引用数据类型，向方法中传入方法使用`lambda expression`或` method reference`
  + 任意数量参数`varargs`使用`...`快速构建参数数组
  + Java函数传参通过值传递，基本类型变量传递变量值，引用类型变量传递引用值

## 对象

+ 创建一个对象需要三步，声明，实例化，初始化
+ 声明一个变量来引用对象，声明一个引用类型变量并未创建对象，其值未确定。当声明基本数据类型时，会预定其所需的内存
+ `new`操作符实例化一个类，分配所需内存，调用构造函数，返回对象引用
+ 垃圾收集：当一个对象无引用时GC会自动回收它

## 类和对象的更多内容

+ 方法返回
  + 执行完所有语句
  + 遇到`return`语句
  + 抛出异常
+ 协变返回类型：返回类型是类时，可以返回它或它子类的对象。返回类型是接口时，可以返回任一个实现了此接口的类的对象
+ `this` 实例方法和构造函数中this是当前对象的引用。指代字段；显示构造方法调用（放在第一行）
+ 访问控制
  + 类有`public`和`package-private`（无修饰符）
  + 类成员有`public`,`package-private`,`private`,`protected`
  + `protected`限制同一个包内的类和其他包内的字类可访问
+ 类成员
  + 类变量
  + 类方法；类方法不能访问实例变量和实例方法，而需要通过对象的引用
  + 使用`static`和`final`组合创建常量，命名大写并使用下划线隔开，如果常量值改变需重新编译文件
+ 字段初始化
  + 在声明时进行初始化，但不能处理复杂的任务
  + 静态初始化块：对类变量进行初始化，也可以通过私有的静态方法对类变量进行初始化
  + 实例变量初始化，初始化块和final函数

## 内嵌类

+ Java语言中内嵌类分类两类：静态的和非静态的，静态的内嵌类称为`static nested classes`，非静态的内嵌类称为`inner classes`。inner class可以访问类中的其他成员，而static nested class不能
+ 为什么使用内嵌类
  + 将只用在一个地方的类进行逻辑分组
  + 增加封装性
  + 提高可读性和可维护能力
+ 静态内嵌类 不可直接访问外部类的成员，需要通过对象引用访问。类名使用`OuterClass.StaticNestedClass`形式
+ inner class适合具体的实例相关联的，其内部不可以有静态成员；必须先生成一个外部类的对象才能利用它生成一个内部类对象，格式如下`OuterClass.InnerClass innerObject = outerObject.new InnerClass()`
+ inner class内部访问外部类成员`OuterClass.this.xxxxx`
+ 局部类 在块中定义的类。局部类可以访问外部类成员并且可以访问所处块的`final`或`effectively final`变量，如果定义在方法内可以访问方法参数
+ 匿名内部类 适合类只使用一次的情况，以更简洁的方式声明并创建对象。匿名内部类适合两个方法及以上接口的实现
+ lambda表达式
  + 函数接口 只含有一个抽象方法的接口
  + (parameters) -> {statements}
  + 目标类型：只有Java编译器可以确定目标类型时才能使用lambda表达式：变量声明，赋值，返回语句，数组初始化，方法或构造函数参数，lambda表达式体，条件表达式？：，转换表达式
+ 方法引用 当lambda是调用一个已经存在的方法时可替换为这个方法的引用

## 枚举类型

+ 枚举类型是预先定义好的常量的集合，每个枚举类型变量的值必须等于其中的一个。
+ 枚举类型的构造方法必须为私有或者不加修饰符
