# 利用锁解决同步问题

## 同步

* 在大多数实际的多线程应用中,两个或以上的线程需要共享对同一数据的存取.两个线程同时存取相同的对象，并且修改对象状态,将会发生讹误的情况.这种情况称为竞争条件.为了消除讹误，需要对数据进行同步存取.

## 锁对象

* 可以将我们需要同步的代码块用锁锁起来,在代码执行结束后将锁释放,即可实现同步.基本结构如下
```
myLock.lock();
try {
  critical section
} finally {
  myLock.unlock();
}
```
这一结构将保证任何时刻只有一个线程进入临界区
> java.util.concurrent.locks.ReentrantLock实现了java.util.concurrent.locks。Lock接口

## 条件对象

* 通常，线程进入临界区,却发现需要在满足某一条件之后它才能执行,最好使用一个条件对象管理那些已经获得一个锁但是却不能做有用工作的线程.
* 一个锁对象可以有一个或多个相关的条件对象,调用锁对象的`newCondition`方法获得锁的一个相关条件对象.当条件不成立调用条件对象的`await`方法,线程就会放弃锁,进入阻塞.只有当另一个线程调用同一条件上的`signalAll`方法时,会激活因为这一条件而等待的所有线程,注意此方法只是通知正在等待的线程此时有可能满足条件,所以被唤醒的线程应该重新测试该条件.

## 总结

* 锁用来保护代码片段,任何时刻都只能有一个线程执行被保护的代码
* 锁可以管理试图进入试图进入被保护代码短的线程
* 锁可以拥有一个或多个相关的条件对象
* 每个条件对象管理那些已经进入被保护的代码段但是还不能运行的线程
